/*
?–°–æ–∑–¥–∞–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä, —Å–æ–∑–¥–∞—é—â–∏–π –≤–∞—Ä–∏–∞—Ü–∏–∏ —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–¥–∞—á–∏:
?–î–∞–Ω–∞ –º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞–∑–º–µ—Ä–∞ m*n. –£–∫–∞–∑–∞–Ω—ã –¥–≤–µ —Ç–æ—á–∫–∏ - —è—á–µ–π–∫–∞, –æ—Ç–∫—É–¥–∞ –∑–∞—Ö–æ–¥–∏—Ç —á–µ–ª–æ–≤–µ–∫ –∏ —è—á–µ–π–∫–∞ –≥–¥–µ —Å—Ç–æ–∏—Ç –ì–æ—Ä–≥–æ–Ω–∞ –ú–µ–¥—É–∑–∞, –∞ —Ç–∞–∫–∂–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –µ—ë –≤–∑–≥–ª—è–¥–∞ (–≤–≥–ª—è–¥ –∏–¥—ë—Ç –ø—Ä—è–º–æ –∏ –ø–æ–∫—Ä—ã–≤–∞–µ—Ç –≤–µ—Å—å —Å—Ç–æ–±–µ—Ü, –µ—Å–ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ –∏–ª–∏ –≤—Å—é —Å—Ç—Ä–æ–∫—É, –µ—Å–ª–∏ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ). –¢–∞–∫–∂–µ –≤ –º–∞—Ç—Ä–∏—Ü–µ —Ä–∞–∑–º–µ—â–µ–Ω—ã –∫–æ–ª–æ–Ω–Ω—ã –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ç–æ—á–∫–∞—Ö, –∫–æ—Ç–æ—Ä—ã–µ "–æ—Ç–±–∏–≤–∞—é—Ç" –≤–∑–≥–ª—è–¥ –ì–æ—Ä–≥–æ–Ω—ã –≤–æ –≤—Å–µ—Ö 4 –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è—Ö (—Ç–æ –µ—Å—Ç—å –ø–æ –≤—Å–µ–º—É —Å—Ç–æ–ª–±—Ü—É –∏ –≤—Å–µ–π —Å—Ç—Ä–æ–∫–µ, –≥–¥–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è) , —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—è –µ–≥–æ. –ò–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ —á–µ–ª–æ–≤–µ–∫ –æ–∫–∞–º–µ–Ω–µ–µ—Ç, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –∑–∞–π–¥—ë—Ç —á–µ—Ä–µ–∑ –¥–≤–µ—Ä—å, –µ—Å–ª–∏ –≤–∑–≥–ª—è–¥ –º–µ–¥—É–∑—ã –ø—Ä–æ—Ö–æ–¥–∏—Ç —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —è—á–µ–π–∫—É —á–µ–ª–æ–≤–µ–∫–∞ –∏–ª–∏ –≤–∑–≥–ª—è–¥ –æ—Ç–±–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –ø–æ–º–æ—â–∏ –∫–æ–ª–æ–Ω–Ω —Ç–∞–∫, —á—Ç–æ–±—ã –ø—Ä–æ—Ö–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ —Å—Ç–∞—Ä—Ç–æ–≤—É—é —è—á–µ–π–∫—É.
?–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω –Ω–∞—Ä–∏—Å–æ–≤–∞—Ç—å –º–∞—Ç—Ä–∏—Ü—É –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞, —Ç–æ—á–∫—É –≤—Ö–æ–¥–∞ —á–µ–ª–æ–≤–µ–∫–∞ (–æ–Ω–∞ –º–æ–∂–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª—é–±–æ–π –∫—Ä–∞–π–Ω–µ–π —Å—Ç—Ä–æ–∫–µ –∏–ª–∏ —Å—Ç–æ–ª–±—Ü–µ), —Ç–æ—á–∫—É —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –ì–æ—Ä–≥–æ–Ω—ã –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –µ—ë –≤–∑–≥–ª—è–¥–∞. –¢–∞–∫–∂–µ –≤ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã—Ö —è—á–µ–π–∫–∞—Ö –º–∞—Ç—Ä–∏—Ü—ã –Ω—É–∂–Ω–æ –∏–∑–æ–±—Ä–∞–∑–∏—Ç—å –∫–æ–ª–æ–Ω–Ω—ã. –†–µ—à–∞—é—â–∏–π –ø–∞–∑–ª –¥–æ–ª–∂–µ–Ω –±—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, –±—É–¥–µ—Ç –ª–∏ —á–µ–ª–æ–≤–µ–∫ –ø—Ä–µ–≤—Ä–∞—â—ë–Ω –≤ –∫–∞–º–µ–Ω—å –∫–∞–∫ —Ç–æ–ª—å–∫–æ –≤–æ–π–¥—ë—Ç (–æ—Ç –≤–∑–≥–ª—è–¥–∞ –ì–æ—Ä–≥–æ–Ω—ã –ª—é–¥–∏ –ø—Ä–µ–≤—Ä–∞—â–∞—é—Ç—Å—è –≤ –∫–∞–º–Ω–∏) –∏–ª–∏ –∂–µ –Ω–µ—Ç?
! –ù–µ –¥–æ–¥–µ–ª–∞–ª, —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –±–æ–ª–∏ + —Ñ–æ–±–∏—è –≥–ø—Ç
*/

/*
import nightsky::puzzle::Puzzle;
import nightsky::puzzle::PuzzleImage;
import nightsky::puzzle::Reveal;
import nightsky::puzzle::RevealPrecise;
import nightsky::canvas::Canvas;
import nightsky::canvas::Point2D;
import nightsky::canvas::Color;
import nightsky::canvas::TextAlign;
import nightsky::canvas::TextAlignLeft;
import nightsky::canvas::TextAlignRight;
import nightsky::canvas::TextAlignCenter;
import std::math::Math;
import std::collections::List;
import std::collections::ListSort;
import std::string::String;
import community::near::spensa2::plural::PluralRu;

class Main {
    function gen_puzzle() -> Puzzle {
        let matrix_orig: List<List<int> > = [];
        let matrix_duo: List<List<int> > = [];
        let len = [Main::getRandomIntInRange(4, 10), Main::getRandomIntInRange(4, 10)];
        
        for (let i in 0..len[0]) {
            let row: List<int> = [];
            
            for (let j in 0..len[1]) {
                row.push(0)    
            }
            
            matrix_orig.push(row);
            matrix_duo.push(row);
        }
        
        let columns = Main::getRandomIntInRange(0, (len[0] + len[1]) / 2);
        for (let i in 0..columns) {
            let col = [Main::getRandomIntInRange(0, len[0]-1), Main::getRandomIntInRange(0, len[1]-1)];
            matrix_orig[col[0]][col[1]] = 2;
            matrix_duo[col[0]][col[1]] = 2;
        }
        
        let gargona = [Main::getRandomIntInRange(0, len[0]-1), Main::getRandomIntInRange(0, len[1]-1)];
        matrix_orig[gargona[0]][gargona[1]] = 3;
        matrix_duo[gargona[0]][gargona[1]] = 3;
        
        let side = ["–≤–ª–µ–≤–æ", "–≤–ø—Ä–∞–≤–æ", "–≤–≤–µ—Ä—Ö", "–≤–Ω–∏–∑"][Main::getRandomIntInRange(0, 3)]
        
        matrix_duo = Main::processMatrix(matrix_duo, side);
        matrix_orig = Main::syncTwos(matrix_orig, matrix_duo);
        
        let person = [Main::getRandomIntInRange(0, len[0]-1), Main::getRandomIntInRange(0, len[1]-1)];
        let pos = true;
        while (pos && (person[0] == gargona[0] && person[1] == gargona[1])) {
            if (person[1] == 0 || person[1] == len[1]-1) {
                pos = false;
            } else if (person[0] == 0 || person[0] == len[0]-1) {
                pos = false;
            } else {
                person = [Main::getRandomIntInRange(0, len[0]-1), Main::getRandomIntInRange(0, len[1]-1)];
            }
        }
        
        let strMatrix = "\\(\\begin{pmatrix}";
        for (let m in 0..len[0]) {
            for (let i in 0..len[1]) {
                strMatrix += if (matrix_orig[m][i] == 0) {
                    "‚¨ú"
                } else if (matrix_orig[m][i] == 1) {
                    "üü•"
                } else if (matrix_orig[m][i] == 2) {
                    "üîò"
                } else if (matrix_orig[m][i] == 3) {
                    "üë©üèª"
                } else {""}
                + String::from_int(matrix_orig[m][i]);                
            
                if (m == person[0] && i == person[1]) {
                    strMatrix += "üßîüèº"
                }
                
                strMatrix += "&";
            }
            
            strMatrix = strMatrix[0..strMatrix.length()-1] + "\\\\"
        }
        strMatrix += "\\end{pmatrix}\\)";
        
        let name = "–ò–Ω–Ω–∞|–ê–Ω—è|–ê–ª–∏–Ω–∞|–û–ª—è|–ö–∞—Ç—è|–ü–æ–ª–∏–Ω–∞|–ê—Ä–∏–Ω–∞|–í–µ—Ä–∞|–ù–∞–¥—è|–°–æ–Ω—è|–ë—å—è–Ω–∫–∞|–í–∞—Å–∏–ª–∏—Å–∞|–í–∞–Ω–µ—Å—Å–∞|–í–µ—Ä–æ–Ω–∏–∫–∞|–ñ–∞–Ω–Ω–∞".split("|")[Main::getRandomIntInRange(0, 14)];
        let wher = "–≤ —à–∫–æ–ª–µ|–Ω–∞ —Ñ–∞–∫—É–ª—å—Ç–∞—Ç–∏–≤–µ|—É —Ä–µ–ø–µ—Ç–∏—Ç–æ—Ä–∞|–Ω–∞ –æ–ª–∏–º–ø–∏–∞–¥–µ".split("|")[Main::getRandomIntInRange(0, 3)];
        let what = "–∑–∞–¥–∞—á—É|–∑–∞–¥–∞—á—É –Ω–∞ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å|—É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ|—Ç–µ—Å—Ç, –≤ –∫–æ—Ç–æ—Ä–æ–º –µ—Å—Ç—å –∑–∞–¥–∞—á–∞|–¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–¥–∞–Ω–∏–µ|–∑–∞–¥–∞–Ω–∏–µ".split("|")[Main::getRandomIntInRange(0, 5)];
        let task = "–æ—Ç–º–µ—á–µ–Ω|–ø–æ–∫–∞–∑–∞–Ω|–≤—ã—Å—Ç–∞–≤–ª–µ–Ω|—É–∫–∞–∑–∞–Ω|–≤–∏–¥–µ–Ω".split("|")[Main::getRandomIntInRange(0, 4)];
        let task = "–æ—Ç–º–µ—á–µ–Ω–æ|–ø–æ–∫–∞–∑–∞–Ω–æ|–≤—ã—Å—Ç–∞–≤–ª–µ–Ω–æ|—É–∫–∞–∑–∞–Ω–æ|–≤–∏–¥–Ω–æ".split("|")[Main::getRandomIntInRange(0, 4)];
        let task = "–æ—Ç–º–µ—á–µ–Ω–∞|–ø–æ–∫–∞–∑–∞–Ω–∞|–≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∞|—É–∫–∞–∑–∞–Ω–∞|–≤–∏–¥–Ω–∞".split("|")[Main::getRandomIntInRange(0, 4)];
        let task = "–æ—Ç–º–µ—á–µ–Ω—ã|–ø–æ–∫–∞–∑–∞–Ω—ã|–≤—ã—Å—Ç–∞–≤–ª–µ–Ω—ã|—É–∫–∞–∑–∞–Ω—ã|–≤–∏–¥–Ω—ã".split("|")[Main::getRandomIntInRange(0, 4)];
        let whatDo = "–≤—ã—á–∏—Å–ª–∏—Ç—å|–ø–æ–Ω—è—Ç—å|–≤—ã—è—Å–Ω–∏—Ç—å|–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å|–Ω–∞–π—Ç–∏".split("|")[Main::getRandomIntInRange(0, 4)];

        //let conditions = [][Main::getRandomIntInRange(0, 10)];

        let sc = name + " –ø–æ–ª—É—á–∏–ª–∞ " + wher + " " + what + ". "
            + " –ù–∞ –ª–∏—Å—Ç–∏–∫–µ " + task + " "
            + "\n–ï—ë –ø–æ–ø—Ä–æ—Å–∏–ª–∏ " + whatDo + ".";

        if(Main::getRandomIntInRange(0, 1) == 1) {
            sc = "–î–∞–Ω " 
                + "–¢—Ä–µ–±—É–µ—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ";
        }

        let desc = sc 
            + "\n –ü—Ä–∏–º–µ—Ä –≤—ã–≤–æ–¥–∞, —Å–ª–µ–¥—É—é—â–∏–π: \"\""
            + "\n<reveal ans>–û—Ç–≤–µ—Ç</reveal>";

        let expl = "" + strMatrix;

        return new Puzzle {
            question: desc,
            solution: expl,
            images: [],
            reveals: [
                new RevealPrecise {
                    name: "ans",
                    answer: ""
                } as Reveal
            ],
        }
    }

    function getRandomIntInRange(a: int, b: int) -> int {
        return (Math::random() * (b - a + 1) as float + a as float) as int;
    }
    
    function processMatrix(matrix: List<List<int> >, direction: String) -> List<List<int> > {
        let numRows = matrix.length();
        let numCols = matrix[0].length();
        
        let dx = 0;
        let dy = 0;
        if (direction == "–≤–ª–µ–≤–æ") {
            dy = -1;
        } else if (direction == "–≤–ø—Ä–∞–≤–æ") {
            dy = 1;
        } else if (direction == "–≤–≤–µ—Ä—Ö") {
            dx = -1;
        } else if (direction == "–≤–Ω–∏–∑") {
            dx = 1;
        }

        let result = matrix;

        for (let i in 0..numRows) {
            for (let j in 0..numCols) {
                if (matrix[i][j] == 3) {
                    let x = i;
                    let y = j;

                    while (x >= 0 && x < numRows && y >= 0 && y < numCols) {
                        if (result[x][y] == 2) {
                            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–æ—Å–µ–¥–µ–π –≤–æ–∫—Ä—É–≥ 2
                            result = Main::markNeighbors(result, x, y);
                        } else if (result[x][y] == 0) {
                            // –ú–µ–Ω—è–µ–º 0 –Ω–∞ 1
                            result[x][y] = 1;
                        }
                        x += dx;
                        y += dy;
                    }
                }
            }
        }

        return result;
    }

    function markNeighbors(matrix: List<List<int> >, x: int, y: int) -> List<List<int> > {
        let numRows = matrix.length();
        let numCols = matrix[0].length();
        
        let res = matrix;
        
        let queue = [[x, y]];
        let index = 0; // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ —Ç–µ–∫—É—â–∏–π —ç–ª–µ–º–µ–Ω—Ç –≤ –æ—á–µ—Ä–µ–¥–∏

        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è: –≤–≤–µ—Ä—Ö, –≤–Ω–∏–∑, –≤–ª–µ–≤–æ, –≤–ø—Ä–∞–≤–æ
        let directions = [
            [-1, 0], // –≤–≤–µ—Ä—Ö
            [1, 0],  // –≤–Ω–∏–∑
            [0, -1], // –≤–ª–µ–≤–æ
            [0, 1]  // –≤–ø—Ä–∞–≤–æ
        ];

        while (index < queue.length()) {
            let currentX = queue[index][0];
            let currentY = queue[index][1];
            index += 1;

            // –ü–µ—Ä–µ–±–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–π
            for (let d in 0..4) {
                let dx = directions[d][0];
                let dy = directions[d][1];

                let nx = currentX + dx;
                let ny = currentY + dy;

                while (nx >= 0 && nx < numRows && ny >= 0 && ny < numCols) {
                    if (res[nx][ny] == 0) {
                        // –ú–µ–Ω—è–µ–º 0 –Ω–∞ 1
                        res[nx][ny] = 1;
                    } else if (res[nx][ny] == 2) {
                        // –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –Ω–æ–≤—É—é "2", –¥–æ–±–∞–≤–ª—è–µ–º –µ—ë –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
                        res[currentX][currentY] = 1;
                        queue.push([nx, ny]);
                    } 
                    
                    nx += dx;
                    ny += dy;
                }
            }
        }

        return res;
    }
    
    function syncTwos(matrix: List<List<int> >, res: List<List<int> >) -> List<List<int> > {
        let numRows = matrix.length();
        let numCols = matrix[0].length();
        
        let updatedRes = res;

        for (let i in 0..numRows) {
            for (let j in 0..numCols) {
                // –ï—Å–ª–∏ –≤ matrix[i][j] —Å—Ç–æ–∏—Ç 2, –¥–æ–±–∞–≤–ª—è–µ–º 2 –≤ updatedRes[i][j]
                if (matrix[i][j] == 2) {
                    updatedRes[i][j] = 2;
                }
            }
        }

        return updatedRes;
    }
}
*/