/*
?Создайте генератор паззлов, в котором будет дана клавиатура с кириллическими буквами (можно в виде таблицы) и слово. Требуется посчитать, сколько раз при печати этого слова придется перейти с одной строчки клавиатуры на другую строчку. Переходить на другую строчку надо тогда, когда следующая для печати буква находится в отличной строке от той, в которой находится текущая напечатанная буква. Например, для слова "морс" потребуется 2 перехода: с нижней на среднюю, а затем обратно на нижнюю. Не используйте конкретно данный пример в работе.

*/

/*
import nightsky::puzzle::Puzzle;
import nightsky::puzzle::PuzzleImage;
import nightsky::puzzle::Reveal;
import nightsky::puzzle::RevealPrecise;
import nightsky::canvas::Canvas;
import nightsky::canvas::Point2D;
import nightsky::canvas::Color;
import nightsky::canvas::TextAlign;
import nightsky::canvas::TextAlignLeft;
import nightsky::canvas::TextAlignRight;
import nightsky::canvas::TextAlignCenter;
import std::math::Math;
import std::collections::List;
import std::collections::ListSort;
import std::string::String;

class Keys {
    public keys: List<String>
}

class Main {
    function gen_puzzle() -> Puzzle {
        let arrKeyboard = [
            new Keys {keys: ["й", "ц", "у", "к", "е", "н", "г", "ш", "щ", "з", "х", "ъ"]},
            new Keys {keys: ["ф", "ы", "в", "а", "п", "р", "о", "л", "д", "ж", "э"]},
            new Keys {keys: ["я", "ч", "с", "м", "и", "т", "ь", "б", "ю"]}
        ];
        
        let keyboard = "<table>";
        for (let i in 0..arrKeyboard.length()) {
            keyboard += "<tr>";
                
            for (let j in 0..arrKeyboard[i].keys.length()) {
                keyboard += "<td>" + arrKeyboard[i].keys[j] + "</td>";
            }
            
            keyboard += "</tr>";
        }
        keyboard += "</table>";
        let word = [
            "дерево", "река", "солнце", "звезда", "цветок", "лес", "трава", "гора", "океан", "песок", "корабль", "волна",
            "песня", "музыка", "снег", "дождь", "ветер", "небо", "туча", "птица", "лето", "зима", "весна", "осень",
            "день", "ночь", "утро", "вечер", "звук", "тишина", "покой", "мир", "радость", "счастье", "любовь", "дружба",
            "вера", "надежда", "сила", "ум", "мудрость", "знание", "правда", "свобода", "красота", "душа", "сердце",
            "память", "мечта", "жизнь", "судьба", "путь", "дорога", "след", "гора", "лес", "поле", "луг", "сад", "пруд",
            "озеро", "река", "море", "океан", "водопад", "ветер", "буря", "ураган", "туман", "лед", "снег", "град",
            "дождь", "роса", "луна", "солнце", "звезда", "комета", "млечный", "путь", "галактика", "вселенная", "планета",
            "земля", "марс", "юпитер", "сатурн", "нептун", "уран", "венера", "меркурий", "комета", "метеор", "космос",
            "спутник", "астероид", "астрономия", "наука", "физика", "химия", "биология", "география", "история",
            "философия", "математика", "информатика", "технология", "инженер", "архитектор", "учитель", "врач", "ученый",
            "писатель", "поэт", "музыкант", "художник", "артист", "режиссер", "актер", "спортсмен", "полицейский",
            "военный", "пожарный", "летчик", "космонавт", "водитель", "плотник", "механик", "электрик", "слесарь",
            "строитель", "фермер", "рыбак", "охотник", "садовод", "пчеловод", "шахтер", "завод", "фабрика", "магазин",
            "рынок", "базар", "улица", "площадь", "город", "деревня", "село", "поселок", "республика", "край", "область",
            "государство", "страна", "мир", "вселенная", "небо", "земля", "континент", "остров", "полуостров", "река",
            "озеро", "море", "океан", "гора", "холм", "скала", "пещера", "пустыня", "степь", "тундра", "тайга", "лес",
            "луга", "болото", "джунгли", "тропики", "полюс", "арктика", "антарктика", "горы", "долина", "дюна",
            "каньон", "пляж", "берег", "лагуна", "риф", "планктон", "водоросли", "кораллы", "медуза", "краб", "осьминог",
            "акула", "кит", "дельфин", "морж", "пингвин", "тюлень", "морской", "лев", "осетр", "стерлядь", "семга",
            "форель", "карп", "сом", "окунь", "щука", "карась", "ёрш", "рысь", "волк", "медведь", "лось", "заяц", "бобр",
            "лиса", "еж", "олень", "коза", "баран", "корова", "свинья", "курица", "гусь", "утка", "воробей", "синица",
            "сова", "ястреб", "орел", "ворон", "журавль", "лебедь", "аист", "сорока", "скворец", "пчела", "оса", "шмель"
        ][Main::getRandomIntInRange(0, 245)];
        let ans = Main::countRowTransitions(arrKeyboard, word);
        
        let name = "Инна|Аня|Алина|Оля|Катя|Полина|Арина|Вера|Надя|Соня|Бьянка|Василиса|Ванесса|Вероника|Жанна".split("|")[Main::getRandomIntInRange(0, 14)];
        let wher = "в школе|на факультативе|у репетитора|на олимпиаде".split("|")[Main::getRandomIntInRange(0, 3)]
        let what = "задачу|задачу на внимательность|упражнение|тест, в котором есть задача|дополнительное задание|задание".split("|")[Main::getRandomIntInRange(0, 5)]
        let task = "отмечена|показана|выставлена|указана|видна".split("|")[Main::getRandomIntInRange(0, 4)];
        let whatDo = "вычислить|понять|выяснить|определить|найти".split("|")[Main::getRandomIntInRange(0, 4)];

        let conditions1 = [
            "сколько раз при печати этого слова придется перейти с одной строчки клавиатуры на другую строчку",
            "сколько раз при наборе этого слова нужно будет сменить строку на клавиатуре",
            "сколько раз при печати этого слова придётся переходить между строками клавиатуры",
            "сколько раз при вводе этого слова потребуется сменить ряд клавиатуры",
            "сколько раз при наборе слова придётся перемещаться с одной строки клавиатуры на другую",
            "сколько раз при печати слова потребуется перейти на другую строку клавиатуры"
        ][Main::getRandomIntInRange(0, 5)];
        let conditions2 = [
            "Переходить на другую строчку надо тогда, когда следующая для печати буква находится в отличной строке от той, в которой находится текущая напечатанная буква",
            "Переход на другую строку требуется, когда следующая буква расположена в другом ряду клавиатуры, чем текущая",
            "Смена строки происходит, если следующая буква для печати находится на другом ряду клавиатуры",
            "Переходить на другую строку следует, когда следующая буква находится на другой строке клавиатуры по сравнению с текущей",
            "На другую строку нужно переходить, если следующая буква для печати расположена в ином ряду клавиатуры",
            "Смена строки необходима, когда следующая буква находится на другой строке клавиатуры, чем предыдущая"
        ][Main::getRandomIntInRange(0, 5)];

        let sc = name + " получила " + wher + " " + what + ". "
            + " На листике " + task 
            + " клавиатура с кириллическими буквами и слово: " + word 
            + ".\n\n" + keyboard + "\n\nЕё попросили " + whatDo + " , " 
            + conditions1 + ". " + conditions2 + ". ";

        if(Main::getRandomIntInRange(0, 1) == 1) {
            sc = "Дана клавиатура с кириллическими буквами и слово: " + word 
                + ".\n\n" + keyboard + "\n\nТребуется определить, "
                + conditions1 + ". " + conditions2 + ". ";
        }

        let desc = sc
            + "\n Пример вывода, следующий: 4"
            + "\n<reveal ans>Ответ</reveal>";

        let expl = "У нас есть слово: " + word 
            + ". Будем смотреть каждую букву в слове по очереди, находится ли следующая буква на другой строке, от текущей:";
        let transitions = 0;
        let currentRow = -1;
        let letters = word.split("");
        for (let i in 0..word.length()) {
            let found = false;

            for (let row in 0..arrKeyboard.length()) {
                for (let col in 0..arrKeyboard[row].keys.length()) {
                    if (arrKeyboard[row].keys[col] == letters[i+1]) {
                        if (row != currentRow && currentRow != -1) {
                            expl += "\nБуква \"" + letters[i+1] + "\" находится на другой строке, следовательно добавляем единицу к переходу.";
                        } else {
                            if (i == 0) {
                                expl += "\nБуква \"" + letters[i+1] + "\" находится первой, поэтому мы ничего не добавляем.";
                            } else {
                                expl += "\nБуква \"" + letters[i+1] + "\" не находится на другой строке, следовательно ничего не добавляем.";
                            }
                        }
                        currentRow = row;
                        found = true;
                        break;
                    }
                }
                if (found) {break};
            }

            if (!found) {
                continue;
            }
        }
        expl += "\nПолучаем ответ: " + String::from_int(ans);
        
        return new Puzzle {
            question: desc,
            solution: expl,
            images: [],
            reveals: [
                new RevealPrecise {
                    name: "ans",
                    answer: String::from_int(ans)
                } as Reveal
            ],
        }
    }
    
    function countRowTransitions(arrKeyboard: List<Keys>, word: String) -> int {
        let transitions = 0;
        let currentRow = -1;
        let letters = word.split("");

        for (let i in 0..word.length()) {
            let found = false;

            for (let row in 0..arrKeyboard.length()) {
                for (let col in 0..arrKeyboard[row].keys.length()) {
                    if (arrKeyboard[row].keys[col] == letters[i+1]) {
                        if (row != currentRow && currentRow != -1) {
                            transitions += 1;
                        }
                        currentRow = row;
                        found = true;
                        break;
                    }
                }
                if (found) {break};
            }

            if (!found) {
                continue;
            }
        }

        return transitions;
    }
    
    function getRandomIntInRange(a: int, b: int) -> int {
        return (Math::random() * (b - a + 1) as float + a as float) as int;
    }
}
*/